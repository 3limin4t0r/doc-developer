<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<!-- $Id: templates.xml,v 1.3 2010-08-20 11:48:38 mg Exp $ -->

<section>
    <title>Templating Mechanism</title>
    <para>
        The .dtl files are about 70% plain html and just used from frontend modules
        (Kernel/Modules/*.pm). The .dtl files are located under:
        <filename>$OTRS_HOME/Kernel/Output/HTML/Standard/*.dtl</filename>
    </para>
    <para>
        The usable dtl tags and syntax are described below.
    </para>

    <section id="template-formatting">
        <title>Formatting</title>
        <para>
            We use four spaces per indentation level. Example:

         <programlisting><![CDATA[
<div class="MainBox ARIARoleMain SpacingTopLarge">

    <div class="W33pc CenterBox SpacingBottomLarge">
        <div class="WidgetSimple">
            <div class="Header">
                <h2>$Text{"Warning"}</h2>
            </div>
            <div class="Content">
                <h4>
                    $Text{"Message"}: <span class="Error">$Data{"Message"}</span>
                </h4>

                <p class="SpacingTop">
                    $Data{"Comment"}
                </p>

                <p class="SpacingTop">
                    <a href="#" id="GoBack">$Text{"Go back to the previous page"}</a>
                    ...
                </p>
            </div>
        </div>
    </div>

</div>
            ]]></programlisting>
        </para>
    </section>

    <section id="TemplateCommands">
        <title>Template Commands</title>
        <para>
            In the templates you can use various commands to inserte data from the
            running OTRS module, and for commenting. Below you find the list of
            available commands with a description.
        </para>

        <section id="Comment">
            <title>Comment</title>
            <para>
                The dtl comment starts with a # at the beginning of a line and will not be
                shown in the html output. This can be used both for commenting the DTL (=Template) code
                or for disabling parts of it.

                <programlisting><![CDATA[
# this section is temporarily disabled
# <div class="AsBlock">
#     <a href="...">link</a>
# </div>
                ]]></programlisting>
            </para>
        </section>

        <section id="data">
            <title>$Data{""}</title>
            <para>
                If data parameters are given to the templates by the application module,
                these data can be output to the template. <literal>$Data</literal> is
                the most simple, but also most dangerous one. It will insert the data
                parameter whose name is specified inside of the {""} into the template
                as it is, without any HTML quoting.
            </para>
            <warning>
                <para>
                    Because of the missing HTML quoting, this can result in security problems.
                    Never output data that was input by a user without quoting in HTML context.
                    The user could - for example - just insert a <literal><![CDATA[<script>]]></literal> tag,
                    and it would be output on the HTML page generated by OTRS.
                </para>
                <para>
                    Whenever possible, use <link linkend="qdata"><literal>$QData{""}</literal></link> (in HTML) or
                    <link linkend="lqdata"><literal>$LQData{""}</literal></link> (in Links) instead.
                </para>
            </warning>

            <para>
                Example: Whenever we generate HTML in the application, we need to output it to the
                template without HTML quoting, like <literal><![CDATA[<select>]]></literal> elements, which
                are generated by the function <literal>Layout::BuildSelection</literal> in OTRS.

                <programlisting><![CDATA[
<label for="Dropdown">Example Dropdown</label>
$Data{"DropdownString"}
                ]]></programlisting>
            </para>
        </section>

        <section id="qdata">
            <title>$QData{""}</title>
            <para>
                This command has the same function as <link linkend="data"><literal>$Data{""}</literal></link>,
                but it performs HTML quoting on the data as it is inserted to the template.

                <programlisting><![CDATA[
The name of the author is $QData{"Name"}.
                ]]></programlisting>

                It's also possible specify a maximum length for the value.
                If, for example, you just want to show 8 characters of a variable (result will be "SomeName[...]"),
                use the following:

                <programlisting><![CDATA[
The first 20 characters of the author's name: $QData{"Name","20"}.
                ]]></programlisting>
            </para>
        </section>

        <section id="lqdata">
            <title>$LQData{""}</title>
            <para>
                This command has the same function as <link linkend="data"><literal>$Data{""}</literal></link>,
                but it performs <ulink url="http://en.wikipedia.org/wiki/Percent-encoding">URL encoding</ulink>
                on the data as it is inserted to the template. This should be used
                to output single parameter names or values of URLs, to prevent security problems.
                It cannot be used for complete URLs because
                it will also mask <literal>=</literal>, for example.

                <programlisting><![CDATA[
<a href="$Env{"Baselink"};Location=$LQData{"File"}">$QData{"File","110"}</a>
                ]]></programlisting>
            </para>
        </section>

        <section id="env">
            <title>$Env{""}</title>
            <para>
                Inserts the environment variable with the name specified in {""}. Some examples:

                <programlisting><![CDATA[
The current user name is: $Env{"UserFirstname"}

Some other common predefined variables are:

$Env{"SessionID"} --> the current session id
$Env{"Time"} --> the current time e. g.  Thu Dec 27 16:00:55 2001
$Env{"CGIHandle"} --> the current CGI handle e. g.  index.pl
$Env{"UserCharset"} --> the current site charset e. g.  iso-8859-1
$Env{"Baselink"} --> the baselink --> index.pl?SessionID=...
$Env{"UserFirstname"} --> e. g. Dirk $Env{"UserFirstname"}
$Env{"UserLogin"} --> e. g. mgg@x11.org
$Env{"UserIsGroup[users]"} = Yes --> user groups (useful for own links)
$Env{"UserIsGroup[admin]"} = Yes $Env{"Action"} --> the current action
                ]]></programlisting>
            </para>
            <warning>
                <para>
                    Because of the missing HTML quoting, this can result in security problems.
                    Never output data that was input by a user without quoting in HTML context.
                    The user could - for example - just insert a <literal><![CDATA[<script>]]></literal> tag,
                    and it would be output on the HTML page generated by OTRS.
                </para>
                <para>
                    Whenever possible, use <link linkend="qenv"><literal>$QEnv{""}</literal></link> instead.
                </para>
            </warning>
        </section>

        <section id="qenv">
            <title>$QEnv{""}</title>
            <para>
                Works like <link linkend="data"><literal>$Env{""}</literal></link>, but
                performs HTML encoding when the data is inserted to the template.

                <programlisting><![CDATA[
The current user name is: $QEnv{"UserFirstname"}
                ]]></programlisting>
            </para>
        </section>

        <section id="config">
            <title>$Config{""}</title>
            <para>
                With this tag you can insert config variables into the template. Let's
                see an example Kernel/Config.pm:

                <programlisting><![CDATA[
[Kernel/Config.pm]
    # FQDN
    # (Full qualified domain name of your system.)
    $Self->{FQDN} = 'otrs.example.com';
    # AdminEmail
    # (Email of the system admin.)
    $Self->{AdminEmail} = 'admin@example.com';
[...]
                ]]></programlisting>

                To output values from it in the template, use:

                <programlisting><![CDATA[
The hostname is '$Config{"FQDN"}'
The admin email address is '$Config{"AdminEmail"}'
                ]]></programlisting>
            </para>
            <warning>
                <para>
                    Because of the missing HTML quoting, this can result in security problems.
                </para>
                <para>
                    Whenever possible, use <link linkend="quote"><literal>$Quote{"$Config{""}"}</literal></link>.
                </para>
            </warning>
        </section>

        <section id="quote">
            <title>$Quote{""}</title>
            <para>
                This tag can be used to perform quoting on HTML strings, when no other quoting is possible.

                <programlisting><![CDATA[
$Quote{"$Config{"ProductName"}"} ($Quote{"$Config{"Ticket::Hook"}"})
                ]]></programlisting>

                It's also possible specify a maximum length for the value.
                If, for example, you just want to show 8 characters of a variable (result will be "Some lon[...]"),
                use the following:

                <programlisting><![CDATA[
$Quote{"Some long long string", "8"})
                ]]></programlisting>
            </para>
        </section>

        <section id="text">
            <title>$Text{""}</title>
            <para>
                Translates the enlosed string into the current user's selected language
                and performs HTML quoting on the resulting string. If no translation is found,
                the original string will be used.

                <programlisting><![CDATA[
Translate this text: $Text{"Help"}
                ]]></programlisting>

                When translating data coming from the application, use <literal>$Data</literal>
                inside of <literal>$Text</literal>, not <literal>$QData</literal>, to prevent
                double quoting:

                <programlisting><![CDATA[
Translate data from the application: $Text{"$Data{"Type"}"}
                ]]></programlisting>

                You can also specify parameters (%s) inside of the string which should be replaced
                with other data:

                <programlisting><![CDATA[
Translate this text and insert the given data: $Text{"Change %s settings", "$Data{"Type"}"}
                ]]></programlisting>
            </para>
        </section>

        <section id="jstext">
            <title>$JSText{""}</title>
            <para>
                Works in the same way as <link linkend="text"><literal>$Text{""}</literal></link>, but
                does not perform HTML encoding but JavaScript string escaping instead (all
                <literal>'</literal> characters will be encoded as <literal>\'</literal>. So with
                the help of this tag you can make sure that even dynamic strings will not break your
                JavaScript code.

                <programlisting><![CDATA[
window.alert('$JSText{"Some message's content"}');

// after the command was replaced in the template, this will
// result in (for an English speaking agent):

window.alert('Some message\'s content');
                ]]></programlisting>

                Make sure to use <literal>'</literal> as string delimiter for strings where you want
                to use <literal>$JSText</literal> inside.
            </para>
        </section>

        <section id="include">
            <title>$Include{""}</title>
            <para>
                Includes another template file into the current one. The included file may also contain
                template commands.

                <programlisting><![CDATA[
# include Copyright.dtl
$Include{"Copyright"}
                ]]></programlisting>
            </para>
        </section>

        <section id="block">
            <title>dtl:block</title>
            <para>
                With this command, one can specify parts of a template file as a block. This block
                needs to be explicitly filled with a function call from the application, to be
                present in the generated output. The application can call the block 0 (it will not
                be present in the output), 1 or more times (each with possibly a different set of
                data parameters passed to the template).
            </para>
            <para>
                One common use case is the filling of a table with dynamic data:

                <programlisting><![CDATA[
<table class="DataTable">
    <thead>
        <tr>
            <th>$Text{"Name"}</th>
            <th>$Text{"Type"}</th>
            <th>$Text{"Comment"}</th>
            <th>$Text{"Valid"}</th>
            <th>$Text{"Changed"}</th>
            <th>$Text{"Created"}</th>
        </tr>
    </thead>
    <tbody>
<!-- dtl:block:NoDataFoundMsg -->
        <tr>
            <td colspan="6">
                $Text{"No data found."}
            </td>
        </tr>
<!-- dtl:block:NoDataFoundMsg -->
<!-- dtl:block:OverviewResultRow -->
        <tr>
            <td><a class="AsBlock" href="$Env{"Baselink"}Action=$Env{"Action"};Subaction=Change;ID=$LQData{"ID"}">$QData{"Name"}</a></td>
            <td>$Text{"$Data{"TypeName"}"}</td>
            <td title="$QData{"Comment"}">$QData{"Comment","20"}</td>
            <td>$Text{"$Data{"Valid"}"}</td>
            <td>$TimeShort{"$QData{"ChangeTime"}"}</td>
            <td>$TimeShort{"$QData{"CreateTime"}"}</td>
        </tr>
<!-- dtl:block:OverviewResultRow -->
    </tbody>
</table>
                ]]></programlisting>

                The surrounding table with the header is always generated.
                If no data was found, the block <literal>NoDataFoundMsg</literal> is called
                once, resulting in a table with one data row with the message "No data found."
            </para>
            <para>
                If data was found, for each row there is one function call made for the
                block <literal>OverViewResultRow</literal> (each time passing in the data
                for this particular row), resulting in a table with
                as many data rows as results were found.
            </para>
            <para>
                Let's look at how the blocks are called from the application module:

                <programlisting><![CDATA[
 my %List = $Self->{StateObject}->StateList(
    UserID => 1,
    Valid  => 0,
);

# if there are any states, they are shown
if (%List) {

    # get valid list
    my %ValidList = $Self->{ValidObject}->ValidList();
    for ( sort { $List{$a} cmp $List{$b} } keys %List ) {

        my %Data = $Self->{StateObject}->StateGet( ID => $_, );
        $Self->{LayoutObject}->Block(
            Name => 'OverviewResultRow',
            Data => {
                Valid => $ValidList{ $Data{ValidID} },
                %Data,
            },
        );
    }
}

# otherwise a no data found msg is displayed
else {
    $Self->{LayoutObject}->Block(
        Name => 'NoDataFoundMsg',
        Data => {},
    );
}
                ]]></programlisting>

                Note how the blocks have both their name and an optional set of data
                passed in as separate parameters to the block function call. Data inserting
                commands inside a block always need the data provided to the block function
                call of this block, not the <link linkend="using-templates">general template
                rendering call</link>.
            </para>
            <para>
                For details, please refer to the documentation of <literal>Kernel::Output::HTML::Layout</literal>
                on <ulink url="http://dev.otrs/org">dev.otrs.org</ulink>.
            </para>
        </section>
    </section>
    <section id="using-templates">
        <title>Using a template file</title>
        <para>
            Ok, but how to actually process a template file and generate the result? This is really simple:

            <programlisting><![CDATA[
# render AdminState.dtl
$Output .= $Self->{LayoutObject}->Output(
    TemplateFile => 'AdminState',
    Data         => \%Param,
);
            ]]></programlisting>

            In the frontend modules, the <literal>Output()</literal> function of
            <literal>Kernel::Output::HTML::Layout</literal> is called (after all the needed blocks
            have been called in this template) to generate the final output. An optional set of
            data parameters is passed to the template, for all data inserting commands which are not
            inside of a block.
        </para>
    </section>
</section>
