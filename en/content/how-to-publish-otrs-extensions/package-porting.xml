<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<section id="package-porting">
    <title>Package Porting</title>
    <para>
With every new minor or major version of OTRS, you need to port your package(s) and make sure they
still work with the OTRS API.
    </para>
        <section id="package-porting-5-to-6">
            <title>From OTRS 5 to 6</title>
            <para>
                This section lists changes that you need to examine when porting your package from
                OTRS 5 to 6.
            </para>

            <section>
                <title>Date and time calculation</title>
                <para>
                    In OTRS 6, a new module for date and time calculation was added: <literal>Kernel::System::DateTime</literal>. The module <literal>Kernel::System::Time</literal> is now deprecated and should not be used for new code anymore.
                </para>

                <para>
                    The main advantage of the new <literal>Kernel::System::DateTime</literal> module is the support for real time zones like <literal>Europe/Berlin</literal> instead of time offsets in hours like <literal>+2</literal>.
                    Note that also the old <literal>Kernel::System::Time</literal> module has been improved to support time zones. Time offsets have been completely dropped. This means that any code that uses time offsets for calculations
                    has to be ported to use the new <literal>DateTime</literal> module instead. Code that doesn't fiddle around with time offsets itself can be left untouched in most cases. You just have to make sure that upon creation
                    of a <literal>Kernel::System::Time</literal> object a valid time zone will be given.
                </para>

                <para>
                    Here's an example for porting time offset code to time zones:
        <programlisting format="linespecific"><![CDATA[
my $TimeObject     = $Kernel::OM->Get('Kernel::System::Time'); # Assume a time offset of 0 for this time object
my $SystemTime     = $TimeObject->TimeStamp2SystemTime( String => '2004-08-14 22:45:00' );
my $UserTimeZone   = '+2'; # normally retrieved via config or param
my $UserSystemTime = $SystemTime + $UserTimeZone * 3600;
my $UserTimeStamp  = $TimeObject->SystemTime2TimeStamp( SystemTime => $UserSystemTime );
        ]]></programlisting>
Code using the new <literal>Kernel::System::DateTime</literal> module:
        <programlisting format="linespecific"><![CDATA[
my $DateTimeObject = $Kernel::OM->Create('Kernel::System::DateTime'); # This implicitly sets the configured OTRS time zone
my $UserTimeZone   = 'Europe/Berlin'; # normally retrieved via config or param
$DateTimeObject->ToTimeZone( TimeZone => $UserTimeZone );
my $SystemTime    = $DateTimeObject->ToEpoch(); # note that the epoch is independent from the time zone, it's always calculated for UTC
my $UserTimeStamp = $DateTimeObject->ToString();
        ]]></programlisting>

                </para>
            </section>

            <section>
                <title><literal>TicketGet()</literal> value <literal>SolutionTime</literal> renamed to <literal>Closed</literal></title>
                <para>
                    For OTRS 6, all extensions need to be checked and ported from <literal>$Ticket{SolutionTime}</literal> to <literal>$Ticket{Closed}</literal> if <literal>TicketGet()</literal> is called with the <literal>Extended</literal> parameter (see bug<ulink url="http://bugs.otrs.org/show_bug.cgi?id=11872">#11872</ulink>).
                </para>
            </section>

            <section>
                <title>JavaScript removed from templates</title>
                <para>
                    With OTRS 6, all JavaScript - especially located in <literal>JSOnDocumentComplete</literal> blocks - is removed from template files and moved to JavaScript files instead.
                    Only in very rare conditions JavaScript needs to be placed within template files. For all other occurences, place the JS code in module-specific JavaScript files.
                    An <literal>Init()</literal> method within such a JavaScript file is executed automatically on file load (for the initialization of event bindings etc.) if you register
                    the JavaScript file at the OTRS application. This is done by executing <literal>Core.Init.RegisterNamespace(TargetNS, 'APP_MODULE');</literal> at the end of the namespace
                    declaration within the JavaScript file.
                </para>
            </section>

            <section>
                <title>Template files for rich text editor removed</title>
                <para>
                    Along with the refactoring of the JavaScript within template files (see above), the template files for the rich text editor (<literal>RichTextEditor.tt</literal> and
                    <literal>CustomerRichTextEditor.tt</literal>) were removed as they are no longer necessary.
                </para>
                <para>
                    Typically, these template files were included in the module-specific template files within a block:
        <programlisting format="linespecific"><![CDATA[
[% RenderBlockStart("RichText") %]
[% InsertTemplate("RichTextEditor.tt") %]
[% RenderBlockEnd("RichText") %]
        ]]></programlisting>
                    This is no longer needed and can be removed. Instead of calling this block from the perl module, it is now necessary to set the needed rich text parameters there.
                    Instead of:
        <programlisting format="linespecific"><![CDATA[
$LayoutObject->Block(
    Name => 'RichText',
    Data => \%Param,
);
        ]]></programlisting>
                    you now have to call:
        <programlisting format="linespecific"><![CDATA[
$LayoutObject->SetRichTextParameters(
    Data => \%Param,
);
        ]]></programlisting>
                </para>
            </section>

            <section>
                <title>Translations in JavaScript files</title>
                <para>
                    Adding translatable strings in JavaScript was quite difficult in OTRS. The string had to be translated in Perl or in the template and than sent to the JavaScript
                    function. With OTRS 6, translation of strings is possible directly in the JavaScript file. All other workarounds, especially blocks in the templates only for
                    translating strings, should be removed.
                </para>
                <para>
                    Instead, the new JavaScript translation namespace <literal>Core.Language</literal> should be used to translate strings directly in the JS file:
        <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The string to translate');
        ]]></programlisting>
                    It is also possible to handover JS variables to be replaced in the string directly:
        <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The %s to %s', 'string', 'translate');
        ]]></programlisting>
                    Every <literal>%s</literal> is replaced by the variable given as extra parameter. The number of parameters is not limited.
                </para>
            </section>

            <section>
                <title>Handover data from Perl to JavaScript</title>
                <para>
                    To achieve template files without JavaScript code, some other workarounds had to be replaced with an appropriate solution. Besides translations, also the handover
                    of data from Perl to JavaScript has been a problem in OTRS. The workaround was to add a JavaScript block in the template in which JavaScript variables were
                    declared and filled with template tags based on data handed over from Perl to the template.
                </para>
                <para>
                    The handover process of data from Perl to JavaScript is now much easier in OTRS 6. To send specific data as variable from Perl to JavaScript, one only has to call
                    a function on Perl-side. The data is than automatically available in JavaScript.
                </para>
                <para>
                    In Perl you only have to call:
        <programlisting format="linespecific"><![CDATA[
$Self->{LayoutObject}->AddJSData(
    Key   => 'KeyToBeAvailableInJS',
    Value => $YourData,
);
        ]]></programlisting>
                    The <literal>Value</literal> parameter is automatically converted to a JSON object and can also contain complex data.
                </para>
                <para>
                    In JavaScript you can get the data with:
        <programlisting format="linespecific"><![CDATA[
Core.Config.Get('KeyToBeAvailableInJS');
        ]]></programlisting>
                    This replaces all workarounds which need to be removed when porting a module to OTRS 6, because JavaScript in template files is now only allowed in
                    very rare conditions (see above).
                </para>
            </section>

            <section>
                <title>Perldoc structure changed</title>
                <para>
                    The structure of POD in Perl files was slightly improved and should be adapted in all files. POD is now also enforced to be syntactically correct.
                </para>
                <para>
                    What was previously called <literal>SYNOPSIS</literal> is now changed to <literal>DESCRIPTION</literal>, as a synopsis typically provides a few popular code usage examples and not a description of the module itself. An additional synopsis can be provided, of course. Here's how an example:
        <programlisting format="linespecific"><![CDATA[
=head1 NAME

Kernel::System::ObjectManager - Central singleton manager and object instance generator

=head1 SYNOPSIS

    # In toplevel scripts only!
    local $Kernel::OM = Kernel::System::ObjectManager->new();

    # Everywhere: get a singleton instance (and create it, if needed).
    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # Remove singleton objects and all their dependencies.
    $Kernel::OM->ObjectsDiscard(
        Objects            => ['Kernel::System::Ticket', 'Kernel::System::Queue'],
    );

=head1 DESCRIPTION

The ObjectManager is the central place to create and access singleton OTRS objects (via C<L</Get()>>)
as well as create regular (unmanaged) object instances (via C<L</Create()>>).

        ]]></programlisting>
                    In case the <literal>DESCRIPTION</literal> does not add any value to the line in the <literal>NAME</literal> section, it should be rewritten or removed altogether.
                </para>
                <para>
                    The second important change is that functions are now documented as <literal>=head2</literal> instead of the previously used <literal>=item</literal>.
                    <programlisting format="linespecific"><![CDATA[
=head2 Get()

Retrieves a singleton object, and if it not yet exists, implicitly creates one for you.

    my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

    # On the second call, this returns the same ConfigObject as above.
    my $ConfigObject2 = $Kernel::OM->Get('Kernel::Config');

=cut

sub Get { ... }
                    ]]></programlisting>
                </para>
                <para>
                    These changes lead to an improved online API documentation as can be seen in the ObjectManager documentation for <ulink url="http://otrs.github.io/doc/api/otrs/5.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS 5</ulink> and <ulink url="http://otrs.github.io/doc/api/otrs/6.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS 6</ulink>.
                </para>
            </section>

            <section>
                <title>HTML templates for JavaScript</title>
                <para>
                    OTRS 6 exposes new JavaScript template API via <literal>Core.Template</literal>
                    class. You can use it in your JavaScript code in a similar way as you use
                    <literal>TemplateToolkit</literal> from Perl code.
                </para>
                <para>
                    Here's an example for porting existing <literal>jQuery</literal> based code to
                    new template API:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
var DivID = 'MyDiv'.
    DivText = 'Hello, world!';

$('<div />').addClass('CSSClass')
    .attr('id', DivID)
    .text(DivText)
    .appendTo('body');
                    ]]></programlisting>
                </para>
                <para>
                    First, make sure to create a new template file under
                    <literal>Kernel/Output/JavaScript/Templates/Standard</literal> folder. In doing
                    this, you should keep following in mind:
                </para>
                <para>
                    <itemizedlist mark="round">
                        <listitem>
                            <para>
                                Create a subfolder with name of your <literal>Module</literal>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                You may reuse any existing subfolder structure but only if it makes
                                sense for your component (e.g. <literal>Agent/MyModule/</literal> or
                                <literal>Agent/Admin/MyModule/</literal>).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Use <literal>.html.tmpl</literal> as extension for template file.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Name templates succinctly and clearly in order to avoid confusion
                                (i.e. good:
                                <literal>Agent/MyModule/SettingsDialog.html.tmpl</literal>, bad:
                                <literal>Agent/SettingsDialogTemplate.html.tmpl</literal>).
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>
                    Then, add your HTML to the template file, making sure to use placeholders for
                    any variables you might need:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
<div id="{{ DivID }}" class="CSSClass">
    {{ DivText | Translate }}
</div>
                    ]]></programlisting>
                </para>
                <para>
                    Then, just get rendered HTML by calling <literal>Core.Template.Render</literal>
                    method with template path (without extension) and object containing variables
                    for replacement:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
var DivHTML = Core.Template.Render('Agent/MyModule/SettingsDialog', {
    DivID: 'MyDiv',
    DivText: 'Hello, world!'
});

$(DivHTML).appendTo('body');
                    ]]></programlisting>
                </para>
                <para>
                    Internally, <literal>Core.Template</literal> uses Nunjacks engine for parsing
                    templates. Essentially, any valid Nunjacks syntax is supported, please see
                    <ulink url="https://mozilla.github.io/nunjucks/templating.html">their
                    documentation</ulink> for more information.
                </para>
                <para>
                    Here are some tips:
                </para>
                <para>
                    <itemizedlist mark="round">
                        <listitem>
                            <para>
                                You can use <literal>| Translate</literal> filter for string
                                translation to current language.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                All <literal>{{ VarName }}</literal> variable outputs are HTML
                                escaped by default. If you need to output some existing HTML, please
                                use <literal>| safe</literal> filter to bypass escaping.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Use <literal>| urlencode</literal> for encoding url parameters.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Complex structures in replacement object are supported, so feel free
                                to pass arrays or hashes and iterate over them right from template.
                                For example, look at <literal>{% for %}</literal> syntax in
                                <ulink url="https://mozilla.github.io/nunjucks/templating.html#for">
                                Nunjacks documentation</ulink>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>

            <section>
                <title>Checking user permissions</title>
                <para>
                    Before OTRS 6, user permissions were stored in the session and passed to the
                    <code>LayoutObject</code> as attributes, which were then in turn accessed to determine user
                    permissions like <code>if ($LayoutObject->{'UserIsGroup[admin]'}) { ... }</code>.
                </para>
                <para>
                    With OTRS 6, permissions are no longer stored in the session and also not passed to the
                    <code>LayoutObject</code>. Please switch your code to calling <code>PermissionCheck()</code>
                    on <code>Kernel::System::Group</code> (for agents) or <code>Kernel::System::CustomerGroup</code>
                    (for customers). Here's an example:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
my $HasPermission = $Kernel::OM->Get('Kernel::System::Group')->PermissionCheck(
    UserID    => $UserID,
    GroupName => $GroupName,
    Type      => 'move_into',
);
                    ]]></programlisting>
                </para>
            </section>

            <section>
                <title>Ticket and Article API changes</title>
                <para>
                    In OTRS 6, changes to Ticket and Article API have been made, in preparations for
                    new Omni Channel infrastructure.
                </para>
                <para>
                    All methods related to articles have been moved to
                    <literal>Kernel::System::Ticket::Article</literal> object. List of methods that
                    have been migrated can be found <link linkend="otrs6-article-methods">here</link>.
                </para>
                <para>
                    If you are referencing any of these methods via
                    <literal>Kernel::System::Ticket</literal> object in your code, please switch to
                    Article object and use it instead. For example:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
my $TicketObject = $Kernel::OM->Get('Kernel::System::Ticket');

my @Index = $TicketObject->ArticleIndex(
    TicketID => $TicketID,
);
                    ]]></programlisting>
                </para>
                <para>
                    This code now becomes:
                </para>
                <para>
                    <programlisting format="linespecific"><![CDATA[
my $ArticleObject = $Kernel::OM->Get('Kernel::System::Ticket::Article');

my @Index = $ArticleObject->ArticleIndex(
    TicketID => $TicketID,
);
                    ]]></programlisting>
                </para>

                <section id="otrs6-article-methods">
                    <title>OTRS 6 article methods</title>
                    <para>
                        In OTRS 6, following methods have been migrated from
                        <literal>Kernel::System::Ticket</literal> to
                        <literal>Kernel::System::Ticket::Article</literal>:
                    </para>
                    <para>
                        <itemizedlist>
                            <listitem><para>ArticleCreate()</para></listitem>
                            <listitem><para>ArticleGetTicketIDOfMessageID()</para></listitem>
                            <listitem><para>ArticleGetContentPath()</para></listitem>
                            <listitem><para>ArticleSenderTypeList()</para></listitem>
                            <listitem><para>ArticleSenderTypeLookup()</para></listitem>
                            <listitem><para>ArticleTypeLookup()</para></listitem>
                            <listitem><para>ArticleTypeList()</para></listitem>
                            <listitem><para>ArticleLastCustomerArticle()</para></listitem>
                            <listitem><para>ArticleFirstArticle()</para></listitem>
                            <listitem><para>ArticleIndex()</para></listitem>
                            <listitem><para>ArticleContentIndex()</para></listitem>
                            <listitem><para>ArticleGet   ()</para></listitem>
                            <listitem><para>ArticleCount ()</para></listitem>
                            <listitem><para>ArticlePage  ()</para></listitem>
                            <listitem><para>ArticleUpdate()</para></listitem>
                            <listitem><para>ArticleSend  ()</para></listitem>
                            <listitem><para>ArticleBounce()</para></listitem>
                            <listitem><para>SendAutoResponse()</para></listitem>
                            <listitem><para>ArticleFlagSet()</para></listitem>
                            <listitem><para>ArticleFlagDelete()</para></listitem>
                            <listitem><para>ArticleFlagGet()</para></listitem>
                            <listitem><para>ArticleFlagsOfTicketGet()</para></listitem>
                            <listitem><para>ArticleAccountedTimeGet()</para></listitem>
                            <listitem><para>ArticleAccountedTimeDelete()</para></listitem>
                            <listitem><para>ArticleAttachmentIndex()</para></listitem>
                            <listitem><para>ArticleDelete()</para></listitem>
                            <listitem><para>ArticleDeletePlain()</para></listitem>
                            <listitem><para>ArticleDeleteAttachment()</para></listitem>
                            <listitem><para>ArticleWritePlain()</para></listitem>
                            <listitem><para>ArticleWriteAttachment()</para></listitem>
                            <listitem><para>ArticlePlain()</para></listitem>
                            <listitem><para>ArticleAttachment()</para></listitem>
                        </itemizedlist>
                    </para>
                </section>
            </section>

        </section>

        <section id="package-porting-4-to-5">
        <title>From OTRS 4 to 5</title>
        <para>
            This section lists changes that you need to examine when porting your package from
            OTRS 4 to 5.
        </para>

        <section>
            <title><filename>Kernel/Output/HTML</filename> restructured</title>
            <para>
                In OTRS 5, <filename>Kernel/Output/HTML</filename> was restructured. All Perl modules (except <filename>Layout.pm</filename>) were moved to subdirectories (one for every module layer). Template (theme) files were also moved from <filename>Kernel/Output/HTML/Standard</filename> to <filename>Kernel/Output/HTML/Templates/Standard</filename>. Please perform this migration also in your code.
            </para>
        </section>

        <section>
            <title>Pre-Output-Filters</title>
            <para>
                With OTRS 5 there is no support for <literal>pre</literal> output filters any more. These filters changed the template content before it was parsed, and that could potentially lead to bad performance issues because the templates could not be cached any more and had to be parsed and compiled every time.
            </para>
            <para>
                Just switch from <literal>pre</literal> to <literal>post</literal> output filters. To translate content, you can run <code>$LayoutObject->Translate()</code> directly. If you need other template features, just define a small template file for your output filter and use it to render your content before injecting it into the main data. It can also be helpful to use jQuery DOM operations to reorder/replace content on the screen in some cases instead of using regular expressions. In this case you would inject the new code somewhere in the page as invisible content (e. g. with the class <literal>Hidden</literal>), and then move it with jQuery to the correct location in the DOM and show it.
            </para>
            <para>
                To make using post output filters easier, there is also a new mechanism to request HTML comment hooks for certain templates/blocks. You can add in your module config XML like:
            </para>
            <para>
                <programlisting><![CDATA[
<ConfigItem
Name="Frontend::Template::GenerateBlockHooks###100-OTRSBusiness-ContactWithData"
Required="1" Valid="1">
    <Description Translatable="1">Generate HTML comment hooks for
the specified blocks so that filters can use them.</Description>
    <Group>OTRSBusiness</Group>
    <SubGroup>Core</SubGroup>
    <Setting>
        <Hash>
            <Item Key="AgentTicketZoom">
                <Array>
                    <Item>CustomerTable</Item>
                </Array>
            </Item>
        </Hash>
    </Setting>
</ConfigItem>
                ]]></programlisting>
            </para>
            <para>
                This will cause the block <literal>CustomerTable</literal> in <filename>AgentTicketZoom.tt</filename> to be
                wrapped in HTML comments each time it is rendered:
            </para>
            <para>
                <programlisting><![CDATA[
<!--HookStartCustomerTable-->
... block output ...
<!--HookEndCustomerTable-->
                ]]></programlisting>
            </para>
            <para>
                With this mechanism every package can request just the block hooks it
                needs, and they are consistently rendered. These HTML comments can then be used in your
                output filter for easy regular expression matching.
            </para>
        </section>

        <section>
            <title>IE 8 and IE 9</title>
            <para>
                Support for IE 8 and 9 <ulink url="https://github.com/OTRS/otrs/commit/3b1aff21984d7b32f626df95e072337245615b36">was dropped</ulink>. You can remove any workarounds in your code for these platforms, as well as any old <literal>&lt;CSS_IE7&gt;</literal> or <literal>&lt;CSS_IE8&gt;</literal> loader tags that might still lurk in your XML config files.
            </para>
        </section>

        <section>
            <title>GenericInterface API change in "Ticket" connector</title>
            <para>
                The operation <code>TicketGet()</code> returns dynamic field data from ticket and
                articles differently than in OTRS 4. Now they are cleanly  separated from the rest
                of the static ticket and article fields - they are now grouped in a list called
                <literal>DynamicField</literal>. Please adapt any applications using this operation
                accordingly.
            </para>
            <para>
                <programlisting><![CDATA[
# changed from:

Ticket => [
    {
        TicketNumber       => '20101027000001',
        Title              => 'some title',
        ...
        DynamicField_X     => 'value_x',
    },
]

# to:

Ticket => [
    {
        TicketNumber       => '20101027000001',
        Title              => 'some title',
        ...
        DynamicField => [
            {
                Name  => 'some name',
                Value => 'some value',
            },
        ],
    },
]
                ]]></programlisting>
            </para>
        </section>
        <section>
            <title>Preview functions in dynamic statistics</title>
            <para>
                The new statistics GUI provides a preview for the current configuration. This must be implemented
                in the statistic modules and usually returns fake / random data for speed reasons. So for any
                dynamic (matrix) statistic that provides the method <code>GetStatElement()</code> you should also add a method
                <code>GetStatElementPreview()</code>, and for every dynamic (table) statistic that provides
                <code>GetStatTable()</code> you should accordingly add <code>GetStatTablePreview()</code>. Otherwise
                the preview in the new statistics GUI will not work for your statistics. You can find example
                implementations in the default OTRS statistics.
            </para>
        </section>
        <section>
            <title>HTML print discarded</title>
            <para>
                Until OTRS 5, the Perl module <literal>PDF::API2</literal> was not present on all systems. Therefore
                a fallback HTML print mode existed. With OTRS 5, the module is now bundled and HTML print was dropped.
                <code>$LayoutObject->PrintHeader()</code> and <code>PrintFooter()</code> are not available any more.
                Please remove the HTML print fallback from your code and change it to generate PDF if necessary.
            </para>
        </section>
        <section>
            <title>Translation string extraction improved</title>
            <para>
                Until OTRS 5, translatable strings could not be extracted from Perl code and Database XML definitions.
                This is now possible and makes dummy templates like <filename>AAA*.tt</filename> obsolete.
                Please see <link linkend="localization-translation-mechanism">this section</link> for details.
            </para>
        </section>
    </section>

    <section id="package-porting-33-to-4">
        <title>From OTRS 3.3 to 4</title>
        <para>
            This section lists changes that you need to examine when porting your package from
            OTRS 3.3 to 4.
        </para>

        <section id="package-porting-33-to-4-objectmanager">
            <title>New Object Handling</title>
            <para>
                Up to OTRS 4, objects used to be created both centrally and also locally and
                then handed down to all objects by passing them to the constructors.
                With OTRS 4 and later versions, there is now an <literal>ObjectManager</literal>
                that centralizes singleton object creation and access.
            </para>
            <para>
                This will require you first of all to change all top level Perl scripts (.pl files only!)
                to load and provide the <literal>ObjectManager</literal> to all OTRS objects.
                Let's look at <filename>otrs.CheckDB.pl</filename> from OTRS 3.3 as an example:
            </para>
            <para>
                <programlisting><![CDATA[
use strict;
use warnings;

use File::Basename;
use FindBin qw($RealBin);
use lib dirname($RealBin);
use lib dirname($RealBin) . '/Kernel/cpan-lib';
use lib dirname($RealBin) . '/Custom';

use Kernel::Config;
use Kernel::System::Encode;
use Kernel::System::Log;
use Kernel::System::Main;
use Kernel::System::DB;

# create common objects
my %CommonObject = ();
$CommonObject{ConfigObject} = Kernel::Config->new();
$CommonObject{EncodeObject} = Kernel::System::Encode->new(%CommonObject);
$CommonObject{LogObject}    = Kernel::System::Log->new(
    LogPrefix    => 'OTRS-otrs.CheckDB.pl',
    ConfigObject => $CommonObject{ConfigObject},
);
$CommonObject{MainObject} = Kernel::System::Main->new(%CommonObject);
$CommonObject{DBObject}   = Kernel::System::DB->new(%CommonObject);
                ]]></programlisting>
            </para>
            <para>
                We can see that a lot of code is used to load the packages and create the common
                objects that must be passed to OTRS objects to be used in the script. With OTRS 4,
                this looks quite different:
            </para>
            <para>
                <programlisting><![CDATA[
use strict;
use warnings;

use File::Basename;
use FindBin qw($RealBin);
use lib dirname($RealBin);
use lib dirname($RealBin) . '/Kernel/cpan-lib';
use lib dirname($RealBin) . '/Custom';

use Kernel::System::ObjectManager;

# create common objects
local $Kernel::OM = Kernel::System::ObjectManager->new(
    'Kernel::System::Log' => {
        LogPrefix => 'OTRS-otrs.CheckDB.pl',
    },
);

# get database object
my $DBObject = $Kernel::OM->Get('Kernel::System::DB');
                ]]></programlisting>
            </para>
            <para>
                The new code is a bit shorter than the old. It is no longer necessary to load all the
                packages, just the <literal>ObjectManager</literal>. Subsequently <literal>$Kernel::OM->Get('My::Perl::Package')</literal>
                can be used to get instances of objects which only have to be created once. The <literal>LogPrefix</literal> setting
                controls the log messages that <literal>Kernel::System::Log</literal> writes, it could also be omitted.
            </para>
            <para>
                From this example you can also deduce the general porting guide when it comes to accessing
                objects: don't store them in <literal>$Self</literal> any more (unless needed for specific reasons). Just fetch and use
                the objects on demand like <code>$Kernel::OM->Get('Kernel::System::Log')->Log(...)</code>. This also has
                the benefit that the <literal>Log</literal> object will only be created if something must be logged.
                Sometimes it could also be useful to create local variables if an object is used many times in a function,
                like <literal>$DBObject</literal> in the example above.
            </para>
            <para>
                There's not much more to know when porting packages that should be loadable by the <literal>ObjectManager</literal>.
                They should declare the modules they use (via <code>$Kernel::OM->Get()</code>) like this:
            </para>
            <para>
                <programlisting><![CDATA[
our @ObjectDependencies = (
    'Kernel::Config',
    'Kernel::System::Log',
    'Kernel::System::Main',
);
                ]]></programlisting>
            </para>
            <para>
                The <literal>@ObjectDependencies</literal> declaration is needed for the
                <literal>ObjectManager</literal> to keep the correct order when destroying the objects.
            </para>
            <para>
                Let's look at <filename>Valid.pm</filename> from OTRS 3.3 and 4 to see the difference. Old:
            </para>
            <para>
                <programlisting><![CDATA[
package Kernel::System::Valid;

use strict;
use warnings;

use Kernel::System::CacheInternal;

...

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    # check needed objects
    for my $Object (qw(DBObject ConfigObject LogObject EncodeObject MainObject)) {
        $Self->{$Object} = $Param{$Object} || die "Got no $Object!";
    }

    $Self->{CacheInternalObject} = Kernel::System::CacheInternal->new(
        %{$Self},
        Type => 'Valid',
        TTL  => 60 * 60 * 24 * 20,
    );

    return $Self;
}

...

sub ValidList {
    my ( $Self, %Param ) = @_;

    # read cache
    my $CacheKey = 'ValidList';
    my $Cache = $Self->{CacheInternalObject}->Get( Key => $CacheKey );
    return %{$Cache} if $Cache;

    # get list from database
    return if !$Self->{DBObject}->Prepare( SQL => 'SELECT id, name FROM valid' );

    # fetch the result
    my %Data;
    while ( my @Row = $Self->{DBObject}->FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # set cache
    $Self->{CacheInternalObject}->Set( Key => $CacheKey, Value => \%Data );

    return %Data;
}
                ]]></programlisting>
            </para>
            <para>
                New:
            </para>
            <para>
                <programlisting><![CDATA[
package Kernel::System::Valid;

use strict;
use warnings;

our @ObjectDependencies = (
    'Kernel::System::Cache',
    'Kernel::System::DB',
    'Kernel::System::Log',
);

...

sub new {
    my ( $Type, %Param ) = @_;

    # allocate new hash for object
    my $Self = {};
    bless( $Self, $Type );

    $Self->{CacheType} = 'Valid';
    $Self->{CacheTTL}  = 60 * 60 * 24 * 20;

    return $Self;
}

...

sub ValidList {
    my ( $Self, %Param ) = @_;

    # read cache
    my $CacheKey = 'ValidList';
    my $Cache    = $Kernel::OM->Get('Kernel::System::Cache')->Get(
        Type => $Self->{CacheType},
        Key  => $CacheKey,
    );
    return %{$Cache} if $Cache;

    # get database object
    my $DBObject = $Kernel::OM->Get('Kernel::System::DB');

    # get list from database
    return if !$DBObject->Prepare( SQL => 'SELECT id, name FROM valid' );

    # fetch the result
    my %Data;
    while ( my @Row = $DBObject->FetchrowArray() ) {
        $Data{ $Row[0] } = $Row[1];
    }

    # set cache
    $Kernel::OM->Get('Kernel::System::Cache')->Set(
        Type  => $Self->{CacheType},
        TTL   => $Self->{CacheTTL},
        Key   => $CacheKey,
        Value => \%Data
    );

    return %Data;
}
                ]]></programlisting>
            </para>
            <para>
                You can see that the dependencies are declared and the objects are only fetched on demand.
                We'll talk about the <literal>CacheInternalObject</literal> in the next section.
            </para>
        </section>

        <section id="package-porting-33-to-4-cache">
            <title><literal>CacheInternalObject</literal> removed</title>
            <para>
                Since <literal>Kernel::System::Cache</literal> is now also able to cache in-memory,
                <literal>Kernel::System::CacheInternal</literal> was dropped. Please see the previous example
                for how to migrate your code: you need to use the global <literal>Cache</literal> object and pass the <literal>Type</literal>
                settings with every call to <code>Get()</code>, <code>Set()</code>, <code>Delete()</code> and <code>CleanUp()</code>. The <literal>TTL</literal> parameter is now optional and defaults to 20 days, so you only have to specify it in <code>Get()</code> if you require a different <literal>TTL</literal> value.
            </para>
            <warning>
                <para>
                    It is especially important to add the <literal>Type</literal> to <code>CleanUp()</code> as otherwise not just the current cache type but the entire cache would be deleted.
                </para>
            </warning>
        </section>

        <section id="package-porting-33-to-4-scheduler-location">
            <title>Scheduler backend files moved</title>
            <para>
                The backend files of the scheduler moved from <filename>Kernel/Scheduler</filename> to
                <filename>Kernel/System/Scheduler</filename>. If you have any custom Task Handler modules,
                you need to move them also.
            </para>
        </section>

        <section id="package-porting-33-to-4-sopm-code-tags">
            <title>Update <link linkend="package-code-install">code sections</link> in SOPM files</title>
            <para>
                Code tags in SOPM files have to be updated. Please do not use <literal>$Self</literal> any more.
                In the past this was used to get access to OTRS objects like the <literal>MainObject</literal>.
                Please use the <literal>ObjectManager</literal> now. Here is an example for the old style:
            </para>
            <para>
                <programlisting><![CDATA[
<CodeInstall Type="post">

# define function name
my $FunctionName = 'CodeInstall';

# create the package name
my $CodeModule = 'var::packagesetup::' . $Param{Structure}->{Name}->{Content};

# load the module
if ( $Self->{MainObject}->Require($CodeModule) ) {

    # create new instance
    my $CodeObject = $CodeModule->new( %{$Self} );

    if ($CodeObject) {

        # start method
        if ( !$CodeObject->$FunctionName(%{$Self}) ) {
            $Self->{LogObject}->Log(
                Priority => 'error',
                Message  => "Could not call method $FunctionName() on $CodeModule.pm."
            );
        }
    }

    # error handling
    else {
        $Self->{LogObject}->Log(
            Priority => 'error',
            Message  => "Could not call method new() on $CodeModule.pm."
        );
    }
}

</CodeInstall>
                ]]></programlisting>
            </para>
            <para>
                Now this should be replaced by:
            </para>
            <para>
                <programlisting><![CDATA[
<CodeInstall Type="post"><![CDATA[
$Kernel::OM->Get('var::packagesetup::MyPackage')->CodeInstall();
]]]]><![CDATA[></CodeInstall>
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-33-to-4-template-engine">
            <title>New Template Engine</title>
            <para>
                With OTRS 4, the DTL template engine was replaced by Template::Toolkit.
                Please refer to the <link linkend="TemplatingMechanism">Templating section</link>
                for details on how the new template syntax looks like.
            </para>
            <para>
                These are the changes that you need to apply when converting existing DTL templates
                to the new Template::Toolkit syntax:
            </para>

            <table>
                <caption>Template Changes from OTRS 3.3 to 4</caption>
                <thead>
                     <tr>
                         <td>DTL Tag</td>
                         <td>Template::Toolkit tag</td>
                     </tr>
                 </thead>
                 <tbody>
                    <tr>
                        <td><literal>$Data{"Name"}</literal></td>
                        <td><literal>[% Data.Name %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Data{"Complex-Name"}</literal></td>
                        <td><literal>[% Data.item("Complex-Name") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$QData{"Name"}</literal></td>
                        <td><literal>[% Data.Name | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$QData{"Name", "$Length"}</literal></td>
                        <td><literal>[% Data.Name | truncate($Length) | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$LQData{"Name"}</literal></td>
                        <td><literal>[% Data.Name | uri %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Quote{"Text", "$Length"}</literal></td>
                        <td>cannot be replaced directly, see examples below</td></tr>
                    <tr>
                        <td><literal>$Quote{"$Config{"Name"}"}</literal></td>
                        <td><literal>[% Config("Name") | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Quote{"$Data{"Name"}", "$Length"}</literal></td>
                        <td><literal>[% Data.Name | truncate($Length) | html  %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Quote{"$Data{"Content"}","$QData{"MaxLength"}"}</literal></td>
                        <td><literal>[% Data.Name | truncate(Data.MaxLength) | html  %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Quote{"$Text{"$Data{"Content"}"}","$QData{"MaxLength"}"}</literal></td>
                        <td><literal>[% Data.Content  | Translate | truncate(Data.MaxLength) | html  %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Config{"Name"}</literal></td>
                        <td><literal>[% Config("Name") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Env{"Name"}</literal></td>
                        <td><literal>[% Env("Name") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$QEnv{"Name"}</literal></td>
                        <td><literal>[% Env("Name") | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Text{"Text with %s placeholders", "String"}</literal></td>
                        <td><literal>[% Translate("Text with %s placeholders", "String") | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Text{"Text with dynamic %s placeholders", "$QData{Name}"}</literal></td>
                        <td><literal>[% Translate("Text with dynamic %s placeholders", Data.Name) | html %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>'$JSText{"Text with dynamic %s placeholders", "$QData{Name}"}'</literal></td>
                        <td><literal>[% Translate("Text with dynamic %s placeholders", Data.Name) | JSON %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>"$JSText{"Text with dynamic %s placeholders", "$QData{Name}"}"</literal></td>
                        <td><literal>[% Translate("Text with dynamic %s placeholders", Data.Name) | JSON %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$TimeLong{"$Data{"CreateTime"}"}</literal></td>
                        <td><literal>[% Data.CreateTime | Localize("TimeLong") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$TimeShort{"$Data{"CreateTime"}"}</literal></td>
                        <td><literal>[% Data.CreateTime | Localize("TimeShort") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Date{"$Data{"CreateTime"}"}</literal></td>
                        <td><literal>[% Data.CreateTime | Localize("Date") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>&lt;-- dtl:block:Name --&gt;...&lt;-- dtl:block:Name --&gt;</literal></td>
                        <td><literal>[% RenderBlockStart("Name") %]...[% RenderBlockEnd("Name") %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>&lt;-- dtl:js_on_document_complete --&gt;...&lt;-- dtl:js_on_document_complete --&gt;</literal></td>
                        <td><literal>[% WRAPPER JSOnDocumentComplete %]...[% END %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>&lt;-- dtl:js_on_document_complete_placeholder --&gt;</literal></td>
                        <td><literal>[% PROCESS JSOnDocumentCompleteInsert %]</literal></td>
                    </tr>
                    <tr>
                        <td><literal>$Include{"Copyright"}</literal></td>
                        <td><literal>[% InsertTemplate("Copyright") %]</literal></td>
                    </tr>
                </tbody>
            </table>
            <para>
                There is also a helper script <filename>bin/otrs.MigrateDTLtoTT.pl</filename> that will
                automatically port the DTL files to Template::Toolkit syntax for you. It might fail if you have
                errors in your DTL, please correct these first and re-run the script afterwards.
            </para>

            <para>
                There are a few more things to note when porting your code to the new template engine:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            All language files must now have the <literal>use utf8;</literal> pragma.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>Layout::Get()</code> is now deprecated. Please use <code>Layout::Translate()</code> instead.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            All occurrences of <literal>$Text{""}</literal> in Perl code must now be replaced by calls to <code>Layout::Translate()</code>.
                        </para>
                        <para>This is because in DTL there was no separation between template and data. If DTL-Tags were inserted as part of some data, the engine would still parse them. This is no longer the case in Template::Toolkit, there is a strict separation of template and data.
                        </para>
                        <para>
                            Hint: should you ever need to interpolate tags in data, you can use the <literal>Interpolate</literal> filter for this (<literal>[% Data.Name | Interpolate %]</literal>). This is not recommended for security and performance reasons!
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            For the same reason, dynamically injected JavaScript that was enclosed by <literal>dtl:js_on_document_complete</literal> will not work any more. Please use <code>Layout::AddJSOnDocumentComplete()</code> instead of injecting this as template data.
                        </para>
                        <para>
                            You can find an example for this in <filename>Kernel/System/DynamicField/Driver/BaseSelect.pm</filename>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Please be careful with <literal>pre</literal> output filters (the ones configured in
                            <literal>Frontend::Output::FilterElementPre</literal>). They still work, but they will prevent the template
                            from being cached. This could lead to serious performance issues. You should definitely not have any <literal>pre</literal> output filters that operate on all templates, but limit them to certain templates via configuration setting.
                        </para>
                        <para>
                            The <literal>post</literal> output filters (<literal>Frontend::Output::FilterElementPost</literal>) don't have such strong negative performance effects.
                            However, they should also be used carefully, and not for all templates.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

        <section id="package-porting-33-to-4-fontawesome">
            <title>New FontAwesome version</title>
            <para>
                With OTRS 4, we've also updated FontAwesome to a new version. As a consequence, the icons CSS classes have changed. While previously icons were defined by using a schema like <literal>icon-{iconname}</literal>, it is now <literal>fa fa-{iconname}</literal>.
            </para>
            <para>
                Due to this change, you need to make sure to update all custom frontend module registrations which make use of icons (e.g. for the top navigation bar) to use the new schema. This is also true for templates where you're using icon elements like <literal>&lt;i class="icon-{iconname}"&gt;&lt;/i&gt;</literal>.
            </para>
        </section>

        <section id="package-porting-33-to-4-unit-tests">
            <title>Unit Tests</title>
            <para>
                With OTRS 4, in Unit Tests <literal>$Self</literal> no longer provides common objects like the <literal>MainObject</literal>, for example. Please always use <code>$Kernel::OM->Get('...')</code> to fetch these objects.
            </para>
        </section>

        <section id="package-porting-33-to-4-custom-ticket-history-types">
            <title>Custom Ticket History types</title>
            <para>
                If you use any custom ticket history types, you have to take two steps for them to be displayed correctly
                in <literal>AgentTicketHistory</literal> of OTRS 4+.
            </para>
            <para>
                Firstly, you have to register your custom ticket history types via SysConfig. This could look like:
            </para>
            <para>
                <programlisting><![CDATA[
<ConfigItem Name="Ticket::Frontend::HistoryTypes###100-MyCustomModule" Required="1" Valid="1">
    <Description Translatable="1">Controls how to display the ticket history entries as readable values.</Description>
    <Group>Ticket</Group>
    <SubGroup>Frontend::Agent::Ticket::ViewHistory</SubGroup>
    <Setting>
        <Hash>
            <Item Key="MyCustomType" Translatable="1">Added information (%s)</Item>
        </Hash>
    </Setting>
</ConfigItem>
                ]]></programlisting>
            </para>
            <para>
                The second step is to translate the English text that you provided for the custom ticket history type
                in your translation files, if needed. That's it!
            </para>
            <para>
                If you are interested in the details, please refer to
                <ulink url="https://github.com/OTRS/otrs/commit/454dfac6d4eb85652a267e5e65514e386d3cf275">this commit</ulink>
                for additional information about the changes that happened in OTRS.
            </para>
        </section>

    </section>
</section>
