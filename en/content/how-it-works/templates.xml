<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<section id="TemplatingMechanism">
    <title>Templating Mechanism</title>
    <para>
        Internally, OTRS uses a templating mechanism to dynamically generate its
        HTML pages (and other content), while keeping the program logic (Perl) and
        the presentation (HTML) separate. Typically, a frontend module will use an
        own template file, pass some data to it and return the rendered result to
        the user.
    </para>
    <para>
        The template files are located at:
        <filename>$OTRS_HOME/Kernel/Output/HTML/Standard/*.tt</filename>
    </para>
    <para>
        OTRS relies on <ulink url="http://www.template-toolkit.org/">the Template::Toolkit
        rendering engine</ulink>. The full Template::Toolkit syntax can be used in OTRS templates.
        This section describes some example use cases and OTRS extensions to the Template::Toolkit
        syntax.
    </para>

    <section id="TemplateCommands">
        <title>Template Commands</title>

        <section>
            <title>Inserting dynamic data</title>
            <para>
                In templates, dynamic data must be inserted, quoted etc. This section
                lists the relevant commands to do that.
            </para>

            <section id="data-raw">
                <title><literal>[% Data.Name %]</literal></title>
                <para>
                    If data parameters are given to the templates by the application module,
                    these data can be output to the template. <literal>[% Data.Name %]</literal> is
                    the most simple, but also most dangerous one. It will insert the data
                    parameter whose name is 'Name' into the template as it is, without further processing.
                </para>
                <warning>
                    <para>
                        Because of the missing HTML quoting, this can result in security problems.
                        Never output data that was input by a user without quoting in HTML context.
                        The user could - for example - just insert a <literal><![CDATA[<script>]]></literal> tag,
                        and it would be output on the HTML page generated by OTRS.
                    </para>
                    <para>
                        Whenever possible, use <link linkend="data-html"><literal>[% Data.Name | html %]</literal></link> (in HTML) or
                        <link linkend="data-uri"><literal>[% Data.Name | uri %]</literal></link> (in Links) instead.
                    </para>
                </warning>

                <para>
                    Example: Whenever we generate HTML in the application, we need to output it to the
                    template without HTML quoting, like <literal><![CDATA[<select>]]></literal> elements, which
                    are generated by the function <literal>Layout::BuildSelection()</literal> in OTRS.

                    <programlisting><![CDATA[
<label for="Dropdown">Example Dropdown</label>
[% Data.DropdownString"]
                    ]]></programlisting>
                </para>

                <para>
                    If you have data entries with complex names containing special characters,
                    you cannot use the dot (.) notation to access this data. Use item() instead:
                    <literal>[% Data.item('Complex-name') %]</literal>.
                </para>
            </section>

            <section id="data-html">
                <title><literal>[% Data.Name | html %]</literal></title>
                <para>
                    This command has the same function as <link linkend="data-raw">the previous one</link>,
                    but it performs HTML quoting on the data as it is inserted to the template.

                    <programlisting><![CDATA[
The name of the author is [% Data.Name | html %].
                    ]]></programlisting>

                    It's also possible specify a maximum length for the value.
                    If, for example, you just want to show 8 characters of a variable (result will be "SomeName[...]"),
                    use the following:

                    <programlisting><![CDATA[
The first 20 characters of the author's name: [% Data.Name | truncate(20) | html %].
                    ]]></programlisting>
                </para>
            </section>

            <section id="data-uri">
                <title><literal>[% Data.Name | uri %]</literal></title>
                <para>
                    This command performs
                    <ulink url="http://en.wikipedia.org/wiki/Percent-encoding">URL encoding</ulink>
                    on the data as it is inserted to the template. This should be used
                    to output single parameter names or values of URLs, to prevent security problems.
                    It cannot be used for complete URLs because
                    it will also mask <literal>=</literal>, for example.

                    <programlisting><![CDATA[
<a href="[% Env("Baselink") %];Location=[% Data.File | uri %]">[% Data.File | truncate(110 | html %]</a>
                    ]]></programlisting>
                </para>
            </section>

            <section id="data-json">
                <title><literal>[% Data.Name | JSON %]</literal></title>
                <para>
                    This command outputs a string or another data structure as a JavaScript JSON string.

                    <programlisting><![CDATA[
var TreeData = [% Data.TreeData | JSON %];
                    ]]></programlisting>
                </para>
            </section>

            <section id="env">
                <title><literal>[% Env() %]</literal></title>
                <para>
                    Inserts environment variables provided by the LayoutObject. Some examples:

                    <programlisting><![CDATA[
The current user name is: $Env{"UserFirstname"}

Some other common predefined variables are:

[% Env("SessionID") %] --> the current session id
[% Env("Time") %] --> the current time e. g.  Thu Dec 27 16:00:55 2001
[% Env("CGIHandle") %] --> the current CGI handle e. g.  index.pl
[% Env("UserCharset") %] --> the current site charset e. g.  iso-8859-1
[% Env("Baselink") %] --> the baselink --> index.pl?SessionID=...
[% Env("UserFirstname") %] --> e. g. Dirk [% Env("UserFirstname") %]
[% Env("UserLogin") %] --> e. g. mgg@x11.org
[% Env("UserIsGroup[) %]sers]"} = Yes --> user groups (useful for own links)
[% Env("UserIsGroup[) %]dmin]"} = Yes $Env{"Action"} --> the current action
                    ]]></programlisting>
                </para>
                <warning>
                    <para>
                        Because of the missing HTML quoting, this can result in security problems.
                        Never output data that was input by a user without quoting in HTML context.
                        The user could - for example - just insert a <literal><![CDATA[<script>]]></literal> tag,
                        and it would be output on the HTML page generated by OTRS.
                    </para>
                    <para>
                        Don't forget to add the <literal>| html</literal> filter where appropriate.
                    </para>
                </warning>
            </section>

            <section id="config">
                <title><literal>[% Config() %]</literal></title>
                <para>
                    Inserts config variables into the template. Let's see an example Kernel/Config.pm:

                    <programlisting><![CDATA[
[Kernel/Config.pm]
    # FQDN
    # (Full qualified domain name of your system.)
    $Self->{FQDN} = 'otrs.example.com';
    # AdminEmail
    # (Email of the system admin.)
    $Self->{AdminEmail} = 'admin@example.com';
[...]
                    ]]></programlisting>

                    To output values from it in the template, use:

                    <programlisting><![CDATA[
The hostname is '$Config{"FQDN"}'
The admin email address is '[% Config("AdminEmail") %]'
                    ]]></programlisting>
                </para>
                <warning>
                    <para>
                        Because of the missing HTML quoting, this can result in security problems.
                    </para>
                    <para>
                        Don't forget to add the <literal>| html</literal> filter where appropriate.
                    </para>
                </warning>
            </section>
        </section>


        <section>
            <title>Localization Commands</title>
            <section id="text">
                <title><literal>[% Translate() %]</literal></title>
                <para>
                    Translates a string into the current user's selected language.
                    If no translation is found, the original string will be used.

                    <programlisting><![CDATA[
Translate this text: [% Translate("Help") | html %]
                    ]]></programlisting>

                    You can also translate dynamic data by using <literal>Translate</literal>
                    as a filter:

                    <programlisting><![CDATA[
Translate data from the application: [% Data.Type | Translate | html %]
                    ]]></programlisting>

                    You can also specify one or more parameters (<literal>%s</literal>) inside of
                    the string which should be replaced with dynamic data:

                    <programlisting><![CDATA[
Translate this text and insert the given data: [% Translate("Change %s settings", Data.Type) | html %]
                    ]]></programlisting>

                    Strings in JavaScript can be translated and processed with
                    <link linkend="data-json">the JSON filter</link>.

                    <programlisting><![CDATA[
var Text = [% Translate("Change %s settings", Data.Type) | JSON %];
                    ]]></programlisting>

                </para>
            </section>

            <section id="localize">
                <title><literal>[% Localize() %]</literal></title>
                <para>
                    Inserts a localized date/time stamp (including a possible time zone
                    difference of the current agent).
                </para>
                <para>
                    In different cultural areas, different convention for date and time
                    formatting are used. For example, what is the 01.02.2010 in Germany,
                    would be 02/01/2010 in the USA. <literal>[% Localize() %]</literal> abstracts
                    this away from the templates. Let's see an example:

                    <programlisting><![CDATA[
[% Data.CreateTime ǀ Localize("TimeLong") %]
# Result for US English locale:
06/09/2010 15:45:41
                    ]]></programlisting>

                    First, the data is inserted from the application module with <literal>Data</literal>.
                    Here always an ISO UTC timestamp (2010-06-09 15:45:41) must be passed as data to
                    <literal>[% Localize() %]</literal>. Then it will be output it according to the
                    date/time definition of the current locale.
                </para>
                <para>
                    The data passed to <literal>[% Localize() %]</literal> must be UTC. If a time zone offset
                    is specified for the current agent, it will be applied to the UTC timestamp before
                    the output is generated.
                </para>
                <para>
                    There are three different possible output formats: <literal>TimeLong</literal> (full date/time),
                    <literal>TimeShort</literal> (no seconds) and <literal>Date</literal> (no time).
                    <programlisting><![CDATA[
[% Data.CreateTime ǀ Localize("TimeLong") %]
# Result for US English locale:
06/09/2010 15:45:41

[% Data.CreateTime ǀ Localize("TimeShort") %]
# Result for US English locale:
06/09/2010 15:45

[% Data.CreateTime ǀ Localize("TimeShort") %]
# Result for US English locale:
06/09/2010
                    ]]></programlisting>
                </para>
            </section>
        </section>

        <section>
            <title>Template Processing Commands</title>

            <section id="Comment">
                <title>Comment</title>
                <para>
                    Lines starting with a # at the beginning of will not be
                    shown in the html output. This can be used both for commenting the Template code
                    or for disabling parts of it.

                    <programlisting><![CDATA[
# this section is temporarily disabled
# <div class="AsBlock">
#     <a href="...">link</a>
# </div>
                    ]]></programlisting>
                </para>
            </section>

            <section id="include">
                <title><literal>[% InsertTemplate("Copyright.tt") %]</literal></title>
                <para>
                    Includes another template file into the current one. The included file may also contain
                    template commands.

                    <programlisting><![CDATA[
# include Copyright.tt
[% InsertTemplate("Copyright") %]
                    ]]></programlisting>

                    Please note this is not the same as Template::Toolkit's <literal>[% INCLUDE %]</literal>
                    command, which just processes the referenced template. <literal>[% InsertTemplate() %]</literal>
                    actually adds the content of the referenced template into the current template, so that it
                    can be processed together. That makes it possible for the embedded template to access the
                    same environment/data as the main template.
                </para>
            </section>

            <section id="block">
                <title><literal></literal></title>
                <para>
                    With this command, one can specify parts of a template file as a block. This block
                    needs to be explicitly filled with a function call from the application, to be
                    present in the generated output. The application can call the block 0 (it will not
                    be present in the output), 1 or more times (each with possibly a different set of
                    data parameters passed to the template).
                </para>
                <para>
                    One common use case is the filling of a table with dynamic data:

                    <programlisting><![CDATA[
<table class="DataTable">
    <thead>
        <tr>
            <th>[% Translate("Name") | html %]</th>
            <th>[% Translate("Type") | html %]</th>
            <th>[% Translate("Comment") | html %]</th>
            <th>[% Translate("Validity") | html %]</th>
            <th>[% Translate("Changed") | html %]</th>
            <th>[% Translate("Created") | html %]</th>
        </tr>
    </thead>
    <tbody>
[% RenderBlockStart("NoDataFoundMsg") %]
        <tr>
            <td colspan="6">
                [% Translate("No data found.") | html %]
            </td>
        </tr>
[% RenderBlockEnd("NoDataFoundMsg") %]
[% RenderBlockStart("OverviewResultRow") %]
        <tr>
            <td><a class="AsBlock" href="[% Env("Baselink") %]Action=[% Env("Action") %];Subaction=Change;ID=[% Data.ID | uri %]">[% Data.Name | html %]</a></td>
            <td>[% Translate(Data.TypeName) | html %]</td>
            <td title="[% Data.Comment | html %]">[% Data.Comment | truncate(20) | html %]</td>
            <td>[% Translate(Data.Valid) | html %]</td>
            <td>[% Data.ChangeTime | Localize("TimeShort") %]</td>
            <td>[% Data.CreateTime | Localize("TimeShort") %]</td>
        </tr>
[% RenderBlockEnd("OverviewResultRow") %]
    </tbody>
</table>
                    ]]></programlisting>

                    The surrounding table with the header is always generated.
                    If no data was found, the block <literal>NoDataFoundMsg</literal> is called
                    once, resulting in a table with one data row with the message "No data found."
                </para>
                <para>
                    If data was found, for each row there is one function call made for the
                    block <literal>OverViewResultRow</literal> (each time passing in the data
                    for this particular row), resulting in a table with
                    as many data rows as results were found.
                </para>
                <para>
                    Let's look at how the blocks are called from the application module:

                    <programlisting><![CDATA[
my %List = $Self->{StateObject}->StateList(
    UserID => 1,
    Valid  => 0,
);

# if there are any states, they are shown
if (%List) {

    # get valid list
    my %ValidList = $Self->{ValidObject}->ValidList();
    for my $ListKey ( sort { $List{$a} cmp $List{$b} } keys %List ) {

        my %Data = $Self->{StateObject}->StateGet( ID => $ListKey );
        $Self->{LayoutObject}->Block(
            Name => 'OverviewResultRow',
            Data => {
                Valid => $ValidList{ $Data{ValidID} },
                %Data,
            },
        );
    }
}

# otherwise a no data found msg is displayed
else {
    $Self->{LayoutObject}->Block(
        Name => 'NoDataFoundMsg',
        Data => {},
    );
}
                    ]]></programlisting>

                    Note how the blocks have both their name and an optional set of data
                    passed in as separate parameters to the block function call. Data inserting
                    commands inside a block always need the data provided to the block function
                    call of this block, not the <link linkend="using-templates">general template
                    rendering call</link>.
                </para>
                <para>
                    For details, please refer to the documentation of <literal>Kernel::Output::HTML::Layout</literal>
                    on <ulink url="http://otrs.github.io/doc">otrs.github.io/doc</ulink>.
                </para>
            </section>
        </section>
        <section>
            <title><literal>[% WRAPPER JSOnDocumentComplete %]...[% END %]</literal></title>
            <para>
                Marks JavaScript code which should be executed after all CSS, JavaScript
                and other external content has been loaded and the basic JavaScript initialization
                was finished. Again, let's look at an example:

                <programlisting><![CDATA[
<form action="[% Env("CGIHandle") %]" method="post" enctype="multipart/form-data" name="MoveTicketToQueue" class="Validate PreventMultipleSubmits" id="MoveTicketToQueue">
    <input type="hidden" name="Action"       value="[% Env("Action") %]"/>
    <input type="hidden" name="Subaction"    value="MoveTicket"/>

    ...

    <div class="Content">
        <fieldset class="TableLike FixedLabel">
            <label class="Mandatory" for="DestQueueID"><span class="Marker">*</span> [% Translate("New Queue") | html %]:</label>
            <div class="Field">
                [% Data.MoveQueuesStrg %]
                <div id="DestQueueIDError" class="TooltipErrorMessage" ><p>[% Translate("This field is required.") | html %]</p></div>
                <div id="DestQueueIDServerError" class="TooltipErrorMessage"><p>[% Translate("This field is required.") | html %]</p></div>
[% WRAPPER JSOnDocumentComplete %]
<script type="text/javascript">
    $('#DestQueueID').bind('change', function (Event) {
        $('#NoSubmit').val('1');
        Core.AJAX.FormUpdate($('#MoveTicketToQueue'), 'AJAXUpdate', 'DestQueueID', ['NewUserID', 'OldUserID', 'NewStateID', 'NewPriorityID' [% Data.DynamicFieldNamesStrg %]]);
    });
</script>
[% END %]
                    </div>
                    <div class="Clear"></div>
                ]]></programlisting>

                This snippet creates a small form and puts an onchange-Handler on the
                &lt;select&gt; element which triggers an AJAX based form update.
            </para>
            <para>
                Why is it neccessary to enclose the JavaScript code in
                <literal>[% WRAPPER JSOnDocumentComplete %]...[% END %]</literal>?
                Starting with OTRS 3.0, JavaScript loading was
                moved to the footer part of the page for performance reasons. This means that
                within the &lt;body&gt; of the page, no JavaScript libraries are loaded yet.
                With <literal>[% WRAPPER JSOnDocumentComplete %]...[% END %]</literal> you can make sure that this
                JavaScript is moved to a part of the final HTML document, where it will be
                executed only after the entire external JavaScript and CSS content has been
                successfully loaded and initialized.
            </para>
            <para>
                Inside the <literal>[% WRAPPER JSOnDocumentComplete %]...[% END %]</literal> block, you can use
                &lt;script&gt; tags to enclose your JavaScript code, but you do not have to do so.
                It may be beneficial because it will enable correct syntax highlighting in IDEs
                which support it.
            </para>
        </section>
    </section>

    <section id="using-templates">
        <title>Using a template file</title>
        <para>
            Ok, but how to actually process a template file and generate the result? This is really simple:

            <programlisting><![CDATA[
# render AdminState.tt
$Output .= $Self->{LayoutObject}->Output(
    TemplateFile => 'AdminState',
    Data         => \%Param,
);
            ]]></programlisting>

            In the frontend modules, the <literal>Output()</literal> function of
            <literal>Kernel::Output::HTML::Layout</literal> is called (after all the needed blocks
            have been called in this template) to generate the final output. An optional set of
            data parameters is passed to the template, for all data inserting commands which are not
            inside of a block.
        </para>
    </section>
</section>
